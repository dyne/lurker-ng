The storage component's functional I/O requirements include:
	watching for new messages to index
	maintaining all the databases
	purging rendered files which have been obsoleted
	accepting queries from the render component

Current non-functional goals:
	4 billion messages total -> still fast (<= 0.001s)
	>100 messages a second on import even when at 1 billion messages

It must support these queries:
	starting at offset <x> give me the <y> summary blocks for search <z>
		-> this is used for (obviously) search results
		-> it is also used for mailing list summaries (mindex)
	
	starting at offset <x> give me the <y> tids in mbox <z>
		-> this is used for tindex

	give me all the information for mid <x>

	give me all the summary blocks for messages in thread <x>
		-> can say 'error, not head, try this: '
			= we make a symlink

Component diagram:

main--> service --------+------------\
  |        |            |            |
  v        v            v            v
mbox--> summary      search -----> breader
  |        |                         |
  |        v                         |
  +---> config  <-----------------\  |
  |                               |  |
  |                               |  v
  +---> indexer -> wbuffer <--> flatfile

Every component must provide these methods:
	lu_component_init
	lu_component_open
	lu_component_sync
	lu_component_close
	lu_component_quit

load order:
	common
	config
	flatfile
	wbuffer
	indexer
	summary
	mbox
	breader
	search
	service

main:
	Starts up the program
	Loads the config file
	Initializes the components
	Hooks signals for clean shutdown
	Opens up the service port
	Fires up st
	Connects the mbox tailer to libst
	Watches for new connects
		-> creates a new thread
		-> watches for requests
		-> passes them off to the service

mbox:
	Knows how to follow mboxes for appends and import messages
	Detects mailbox append
		-> adds the summary information for the message
		-> invokes the indexer on the message
		-> invokes the summary reply-to resolver

service:
	Knows how to deal with request from the cgi
	Receives requests
	Decides which handler to use
	Access the appropriate subsystem

summary:
	Knows how to manage digested mail information
	Provides summary add method
	Provides summary reply-to resolver
	Provides retrieval functions for retrieval of summary information

config:
	Knows how to load the config file
	Stores the configuration in a global
	!!! should support config file reloading

flatfile:
	Knows how to manage the keyword flatfile database
	Provides a method for append to a keyword record
	Provides an abstracted read interface

breader:
	Knows how to use the abstracted read interface for buffered access
	Provides a method to find the largest record >= it's argument

search:
	Uses the breader to execute a given search

wbuffer:
	Implements a buffering system that delays appends to the flatfile
	Provides a method to flush the whole cache
	Provides a method to flush a specific word
	Provides a buffer append method

indexer:
	Handles indexing a message for keyword searching
	Accepts a message
	Decides what the keywords in the body and subject are
	Pushes the document to all of them
	Pushes all the arbirary search words

Source code layout:
	Every file has a header describing it's public interface.
	
	All public  methods must be called lu_component_*
	All private methods must be called my_component_* and static
	
	Public / private struct obey the same conventions
	
	Every file is _GNU_SOURCE
	Our include headers should precede system headers
	Only those headers shown as DIRECT dependencies may be included
		( exception: main.c needs to init everyone )
	
	goto may be used, but ONLY as an error rollback system

Source section order:
	Header block
	define _GNU_SOURCE
	our includes
	system setup stuff (includes etc)
	constants

	private types
	private globals

	public types
	public globals

	private methods

	public module methods
	public methods
